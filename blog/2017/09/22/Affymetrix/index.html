<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Affymetrix芯片原理 · Kaige Dong&#x27;s Site</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="#  Affymetrix芯片原理"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Affymetrix芯片原理 · Kaige Dong&#x27;s Site"/><meta property="og:type" content="website"/><meta property="og:url" content="https://kaigedong.github.io/Linux-best-practice/blog/2017/09/22/Affymetrix"/><meta property="og:description" content="#  Affymetrix芯片原理"/><meta property="og:image" content="https://kaigedong.github.io/Linux-best-practice/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://kaigedong.github.io/Linux-best-practice/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/Linux-best-practice/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://kaigedong.github.io/Linux-best-practice/blog/atom.xml" title="Kaige Dong&#x27;s Site Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://kaigedong.github.io/Linux-best-practice/blog/feed.xml" title="Kaige Dong&#x27;s Site Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/Linux-best-practice/js/scrollSpy.js"></script><link rel="stylesheet" href="/Linux-best-practice/css/main.css"/><script src="/Linux-best-practice/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/Linux-best-practice/"><img class="logo" src="/Linux-best-practice/img/favicon.ico" alt="Kaige Dong&#x27;s Site"/><h2 class="headerTitleWithLogo">Kaige Dong&#x27;s Site</h2></a><a href="/Linux-best-practice/versions"><h3>0.1.5</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/Linux-best-practice/docs/doc1" target="_self">Docs</a></li><li class=""><a href="/Linux-best-practice/docs/doc4" target="_self">API</a></li><li class=""><a href="/Linux-best-practice/help" target="_self">Help</a></li><li class="siteNavGroupActive"><a href="/Linux-best-practice/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>All blog posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All blog posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/09/20/scrapy_to_search_engine_Introduction">1.爬虫课程的介绍</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/04/09/Python_sorting">Python排序算法</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/04/09/Learn_make_Donot_starve_mods">学习制作饥荒mod</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/04/09/Donot_starve_mod1">饥荒mod1</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/04/09/python_virtual_env">virtualenv 和 pyenv的使用</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/16/Wuenda_machine_learning">吴恩达机器学习笔记</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/13/Django-Apache-wsgi-_deploy">Django+Apache wsgi 部署</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/12/Apache-deploy-Django">Apache 部署 Django</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/09/pytorch-60min">PyTorch 60min教程</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/09/no_root_install_Apache">无root安装Apache</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/07/GIVEinstall">GIVE安装笔记</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/06/wali_v2ray">搬瓦工2: v2ray</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/08/16/Curses-python3-7">Curses_python3.7</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/05/12/wali_note">搬瓦工笔记1：ssr</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/19/DQN_5">强化学习实战：从零开始下五子棋</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/17/DQN_Sarsa">强化学习之Sarsa</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/17/DQN_Sarsa-lambda">增强学习之Sarsa(lambda)</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/16/DQN_Q-learning">深度学习02之Q-learning介绍</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/16/DQN">强化学习介绍与分类01</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/08/07_shadowsocks_settings">shadowsocks配置</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/07/19_shell_env_set/env-export">shell变量及进程及set,env,export</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/07/12_Perl/install_models">Perl安装模块与卸载</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/07/11_python_convert_exe_videos">python批量转换exe视频</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/09_no_root_install_MySQL">服务器无root安装MySQL</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/05/08_Macinstall_MySQL">Mac安装MySQL &amp; Ubuntu下安装MySQL记录</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/tmus">tmus指南</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/17_DQN_DQN">增强学习之DQN介绍</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/17_DQN2/Algo">增强学习之DQN算法</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/08/17python的decode/encode-与-r-b-u">python的decode/encode 与 r/b/u</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/08/17_golang_notes">golang笔记</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/12/09_unroot_install_UCSC_genome_browser">modele_name</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/08/13_Acer中Arch安装Secure/boot-EFI-设置">Acer中Arch安装Secure boot EFI 设置</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13_HTMLandCSS_basic_03">HTML与CSS基础03-Web框架与表单设计</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2019/08/20_Linux_crontab">Linux crontab定时任务</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/learn-git">learn-git</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/items2">items2技巧</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/chenwei_gene_A07-A09">陈巍学基因A07-A09</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/chenwei_gene_A01-A03">陈巍学基因A01-A03</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/chenwei_geneA04-A06">陈巍学基因A04-A06</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/boxplot">数据可视化之柱状图</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/begin_building_sites">开始建站Hexo+NexT</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/Hexo-NexT404pages">Hexo-NexT主题的404页面</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/HTMLandCSS_basic_01">HTML和CSS基础01-html的语法和基本结构文档设置标记</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2018/04/13/HTML_CSS_basic2">HTML和CSS基础02-图像超链接和表格</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/26/pig_exons">modele_name</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/26/Counting-known-microRNAs-in-five-easy-steps">Counting known microRNAs in five easy steps</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/26/R_214">R极客的情人节</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/25/Adapter-and-quality-trimming-of-illumina-data">Adapter and quality trimming of illumina data</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/23/pytorch_bach">pytorch批训练</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/23/pytorch-Optimizer">pytorch:Optimizer优化器</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/23/pytorch-CNN">pytorch:CNN卷积神经网络</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/sync_server_files">同步服务器文件夹</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch07">pytorch07</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch06">pytorch06</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch05">pytorch05</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/Affymetrix">Affymetrix芯片原理</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch03">pytorch03</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch02">pytorch02</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch01">pytorch 学习笔记</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/matlab04">matlab04图像的增强处理</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/matlab03">matlab03图像的几何变换</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/matlab02">matlab02图像的点运算</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/matlab">matlab学习笔记01</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/WEB_frame">WEB框架</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/ChIP-seq-masc">ChIP-seq-macs</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/CSS">CSS层叠样式表</a></li><li class="navListItem"><a class="navItem" href="/Linux-best-practice/blog/2017/09/22/pytorch04">pytorch04</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/Linux-best-practice/blog/2017/09/22/Affymetrix">Affymetrix芯片原理</a></h1><p class="post-meta">September 22, 2017</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">woobamboo</a></p></div></header><div><span><h1><a class="anchor" aria-hidden="true" id="affymetrix芯片原理"></a><a href="#affymetrix芯片原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Affymetrix芯片原理</h1>
<p>Affymetrix芯片公司的芯片包含了<code>RNA表达量分析（表达谱芯片）</code>、<code>SNP检测(基因分型)</code>、<code>拷贝数变异(Copy Number Variation,CNV)</code>、<code>small RNA</code>、<code>甲基化</code>等多种芯片。</p>
<p>应用最广的芯片:<code>表达谱芯片</code>和<code>SNP分型芯片</code>。</p>
<!--truncate-->
<p>Affymetrix在售的仪器：主要有<strong>四个机型</strong>，从小到大分别是：</p>
<ul>
<li>GeneAtlas：是一个小型系统，可以扫描4张芯片一组的小芯片条。</li>
<li>GeneChip Scanner 3000 7G(简称：7G) 和</li>
<li>GeneChip System 3000 DX2(简称：DX2)：这两个是一个机器的两个版本，其中“7G”是科研型版本，“DX2”是临床版本。</li>
<li>GeneTitan：新的机型，通量更大。</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="芯片制造原理"></a><a href="#芯片制造原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>芯片制造原理</h2>
<p>Affymetrix芯片制造过程，类似于半导体芯片的制造过程，是通过光蚀刻来完成的。生物芯片的<code>基片是一张大的玻璃片，称为“wafer”</code>.</p>
<ul>
<li>首先在玻璃基片上加上<code>保护基团</code></li>
</ul>
<blockquote>
<p>保护基团可以阻止接下来的DNA延长反应；这些保护基团是对光敏感的，受到紫外线的照射，这些基团会从所连接的羟基上掉下来。暴露羟基。</p>
</blockquote>
<ul>
<li>接下来进行光蚀刻。</li>
</ul>
<p>以玻璃基片上的<code>3*2</code>个小格子为例，说明光刻过程：</p>
<ul>
<li>先用一个光罩（mask 1）来遮住一部分的玻璃板区域，进行紫外光照射。</li>
</ul>
<blockquote>
<p>在光罩上是一系列排列整齐的小方格，有些小方格是透明的，有些是不透明的，紫外光透过光罩照到透明格子对应的玻璃基片上，光敏的保护基团会从羟基脱落，而不透明的格子保护基团还在。(蓝色为保护基团，紫外光照将会使其脱落)</p>
</blockquote>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-19.jpg" alt=""></p>
<ul>
<li>接下来把要连接的碱基底物加到玻璃基片上。</li>
</ul>
<blockquote>
<p>这里第一个要加的碱基是‘A’，玻璃基片上，刚才被光照射的格子就会与A结合。而另一部分没被光照射的还仍然带有保护基团。</p>
<p>!注意：<code>加的A碱基也带有保护基团</code>。</p>
</blockquote>
<ul>
<li>下一步，进行光刻，用另一张光罩（mask2）盖在玻璃基片上，紫外光再次透过光罩，去掉<strong>一部分</strong>保护基团，第二章透明、不透明格子的分布与第一张不同。再将T碱基铺到玻璃基片上， 在第二轮去掉了保护基团的位置就会加上T。</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-20.jpg" alt=""></p>
<ul>
<li>然后，用Mask 3 进行下一轮遮盖，紫外光照，然后加上C碱基...</li>
</ul>
<p>这样就会根据设计者的意图，长出DNA链来，<code>这就是探针</code>。</p>
<blockquote>
<p>Affymetrix公司的芯片都是3‘端连在玻璃基片上的。</p>
<p>做<code>表达谱的芯片</code>，也就是测RNA表达量的芯片，探针的长度是<code>25个碱基</code>；<code>SNP分型的芯片</code>，探针长度是<code>30个碱基</code>。</p>
<p>Affymetrix芯片上，长有相同DNA链的一个小点被称为一个<code>Feature</code>，这也是未来芯片扫描图上的一个光点。一张芯片上最多可以有<code>680万个Feature</code>，每个Feature上会有几百万条相同序列的DNA探针。</p>
</blockquote>
<ul>
<li>一个大的玻璃基片，在种好所有的DNA链之后会被裁切成一个一个小玻璃片，每个小玻璃片都有一套完整的探针。每张小玻璃片加上辅助液流的外壳，再打上相应的标识，就成了一张生物芯片。</li>
</ul>
<blockquote>
<p>Affymetrix公司的芯片，它所有设计的探针，都在确定的位置，在最后的芯片判读过程中，也是通过光点的空间位置，来知道测到的是哪个探针。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="表达谱芯片实验原理"></a><a href="#表达谱芯片实验原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>表达谱芯片实验原理</h2>
<p>Affymetrix的表达芯片，分为传统的<code>In Vitro Transcription</code> 芯片和新一代的<code>Whole Transcriptome</code>芯片。</p>
<h3><a class="anchor" aria-hidden="true" id="ivt芯片原理"></a><a href="#ivt芯片原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IVT芯片原理</h3>
<ul>
<li>其中<code>IVT芯片</code>使用<code>Oligo dT引物</code>和<code>T7逆转录酶</code>来得到<code>cDNA链</code>的：</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-1.jpg" alt=""></p>
<p>所以，它得到的cDNA主要是靠近mRNA3’位末端的cDNA，相应的，它的探针也<code>主要针对每个基因的最后一、二个外显子</code>来进行设计。</p>
<blockquote>
<p>比较著名的IVT芯片，有经典的<code>U133芯片</code>，和较为经济的<code>PrimeView芯片</code>。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="wt-芯片原理"></a><a href="#wt-芯片原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>WT 芯片原理</h3>
<ul>
<li>而<code>WT芯片</code>是用<code>随机引物</code>和<code>T7逆转录酶</code>来得到cDNA的:</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-2.jpg" alt=""></p>
<p>所以，它得到的cDNA会覆盖转录本上更多的区域。相应的，它的探针也是针对基因的整个转录本来进行设计的。</p>
<p><strong>WT芯片的好处：</strong></p>
<ol>
<li><p>可以覆盖转录本上更多的区域，实验结果的代表性就更好。</p></li>
<li><p>可以针对因为差异剪接所形成的不同转录本分别设计探针,这样就可以知道不同转录本表达量的情况了。</p></li>
<li><p>可以检测到长链非编码RNA</p></li>
</ol>
<blockquote>
<p>比较著名的WT芯片有<code>HTA 2.0</code>、<code>Exon 1.0</code>、<code>Gene 2.0/2.1</code>等</p>
</blockquote>
<ol>
<li>实验过程中，先通过逆转录得到第一链的cDNA，紧接着就合成第二链的cDNA</li>
</ol>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-3.jpg" alt=""></p>
<ol start="2">
<li>变成双链cDNA之后，这个双链cDNA就可以作为接下来的转录模板了。</li>
<li>接下来，用掺有生物素标记的UTP的聚合反应底物，也就是ATP、 CTP、TTP， 再加上生物素标记的UTP， 形成的4个 单核苷酸的 混合物进行体外转录， 转录得到 <code>cRNA (comple- mentary RNA)</code></li>
</ol>
<blockquote>
<p>因为转录的 原料中含有 被生物素标记的UTP，所以转录出来 的cRNA片段 就是带有生物素标签，然后用这些cRNA片段与芯片进行杂交，</p>
</blockquote>
<ol start="4">
<li>之后，用标记了<code>藻红蛋白的链霉亲和素（SAPE）</code>对芯片进行染色：</li>
</ol>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-4.jpg" alt=""></p>
<blockquote>
<p><code>链霉亲和素</code>会与cRNA上的<code>生物素</code>特异性的结合;
（SAPE上的）<code>藻红蛋白</code>在激发光的照射下，可以发出<code>红色荧光</code></p>
</blockquote>
<ol start="5">
<li>再加入<code>标记了生物素</code>的<code>抗链霉亲和素抗体</code>，抗体就亲和吸附到那些已经吸附在cRNA上的链酶亲和素上。</li>
</ol>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-9.jpg" alt=""></p>
<ol start="6">
<li>亲和吸附完成之后，再加入SAPE对芯片二次染色，SAPE就吸附到那些生物素上。</li>
</ol>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-10.jpg" alt=""></p>
<ol start="7">
<li>通过上述的再次染色，可以把更多的藻红蛋白吸附到目标cRNA片段上以增加荧光强度。</li>
<li>化学反应完成之后，就可以把芯片拿到扫描仪上进行激光扫描了，激光扫描之后，得到一张有着密密麻麻光点的图片，这张图也就是荧光信号的矩阵。</li>
</ol>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-7.jpg" alt=""></p>
<blockquote>
<p>光点的x轴，y轴的位置，也就是探针的ID号，光点的强度，对应着被杂交的cRNA的量。而这个cRNA的量，就反映了对应基因特定mRNA转录本的表达量。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="snp分型芯片原理-基因分型芯片"></a><a href="#snp分型芯片原理-基因分型芯片" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SNP分型芯片原理（基因分型芯片）</h2>
<p>Affymetrix公司的SNP分型芯片有两种实验原理：</p>
<ul>
<li>新的是Axiom芯片，是基于<code>连接反应的</code></li>
<li>老的卡式芯片，是基于目标DNA片段与探针序列进行杂交，看序列是否完全匹配。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="axiom方法及检测原理"></a><a href="#axiom方法及检测原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Axiom方法及检测原理</h3>
<p>有两种探针在起作用，第一种探针是芯片上的捕获探针，30个碱基长，作用是把目标DNA片段固定到芯片表面，第二种探针是显色探针，它负责对SNP芯片进行显色：</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-8.jpg" alt=""></p>
<ul>
<li>显色探针的设计：</li>
</ul>
<p>显色探针共分为四组，<code>A/C/G/T</code>各一组探针，它们都是9个碱基的长度，它们的3‘末端的第一个碱基是特异的，而从第二个碱基到第九个碱基都是<code>简并的</code>，这其中，3’末端C，或者G的，设计成5‘端带一个生物素标签，也就是最后会被染成红色荧光。而3’端是A或者T的，5‘端被设计成带另一种标签，最后被染色成绿色荧光。</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-11.jpg" alt="显色探针"></p>
<ul>
<li>以下，以一个<code>G:T</code>型的SNP位点为例，进行说明：</li>
</ul>
<p>在设计这个SNP位点的探针的时候，所设计的捕获探针，是正好到SNP位点<strong>旁边</strong>的一个碱基，实验过程进行两轮杂交：</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-12.jpg" alt=""></p>
<p>第一轮杂交：目标DNA与芯片进行杂交，结果是芯片上的捕获探针会抓到相匹配的目标DNA片段。</p>
<p>接着加入显色探针，进行第二轮杂交，这一轮杂交，把显色探针杂交到目标DNA片段上。</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-13.jpg" alt=""></p>
<p>然后用连接酶进行连接，因为连接酶会对连接前后几个碱基进行识别，只有前后几个碱基都完全匹配连接才会发生。利用连接酶这种识别作用，让只有与目标DNA片段互补的显色探针才会被连接酶连接到捕获探针上。</p>
<p>连接反应后，把游离的显色探针洗掉，再用带荧光标记的染色试剂进行染色，</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-14.jpg" alt=""></p>
<p>刚才连到捕获探针上的生物素标签就在这个染色过程中被染上红色荧光染料。</p>
<p>反之，如果目标DNA片段上，这个位点是“T”，则会被染成绿色荧光基团。</p>
<p>染色完成后，就可以在激光扫描仪下对芯片进行扫描了。</p>
<blockquote>
<p>扫描过程中，探针发出的光是单纯的红色，则该位点是<code>G型纯合子</code></p>
<p>如果是单纯的绿色，则是<code>T型纯合子</code></p>
<p>如果有红有绿，光强接近，则是<code>G，T杂合子</code></p>
</blockquote>
<p>同样的道理，对于以下四种SNP情况，因为不同基因型会发出不同的光，只要看荧光颜色和强度就可以分辨SNP型了。</p>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-15.jpg" alt=""></p>
<p>而对于<code>A/T</code>和<code>C/G</code>这种荧光相同的，就需要另外的检测方案：</p>
<p>以<code>A/T</code>型为例进行说明:</p>
<ul>
<li>针对A设计一个探针，再针对T设计一个探针，而这些探针，是<strong>覆盖到SNP位点的</strong>。</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-16.jpg" alt=""></p>
<p>这里以一个<code>5'</code>端最后一个碱基为<code>A</code>的捕获探针为例：</p>
<ul>
<li>经过第一轮捕获杂交，目标DNA与之杂交，如果目标DNA是<code>T</code>碱基，则两个片段完美匹配.</li>
<li>经过第二轮杂交，一个显色探针杂交到它的旁边，在经过连接反应，显色探针上的标签就连到了这个捕获探针上。</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-17.jpg" alt=""></p>
<ul>
<li>反之，如果目标片段该SNP位点为<code>A</code>，则与探针上<code>A</code>是不完全匹配的，第二轮杂交过程中，虽然有显色探针停在它的附近，但是不会发生连接反应。随后会被洗脱下来。</li>
<li>这样，在随后的激光扫描过程中，如果探针发出荧光，则说明对应SNP位点有<code>T碱基</code>,如果不发出荧光，则说明无<code>T碱基</code></li>
<li>然后再看芯片上最后一个为<code>T碱基</code>的捕获探针，如果发光，说明有A，如果不发光，说明没有<code>A</code></li>
<li>综合两个探针的情况来看，都发光就说明是<code>A/T</code>杂合子；如果只有捕获探针末位为A的发光，则说明该位点为<code>T纯合子</code>；如果只有末位为T的发光，说明是<code>A纯合子</code></li>
</ul>
<blockquote>
<p>在Axiom芯片中，<code>CHB1</code>和<code>CHB2</code>是两款很常用的针对中国人的SNP分型芯片，它们有130万个SNP位点。</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="卡式snp芯片原理"></a><a href="#卡式snp芯片原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>卡式SNP芯片原理</h3>
<p>而卡式SNP芯片的原理与Axiom检测原理略有不同。</p>
<ul>
<li>卡式芯片不是以连接反应是否发生作为检测依据，而是检测目标DNA片段与捕获探针之间的杂交结果。</li>
<li>在探针设计过程中，对SNP两种情况都设计相应的探针。实验过程中，先把基因组DNA分成2份，</li>
</ul>
<p><img src="/Linux-best-practice/blog/assets/2017-02/2017-02-26-18.jpg" alt=""></p>
<p>一份用<code>Nsp I</code> 酶进行消化;另一份用<code>Sty I</code>酶进行消化，基因组DNA被消化成片断之后，在两头加上接头，进行PCR扩增。</p>
<ul>
<li><p>PCR扩增完成后，会得到长度主要分布在<code>200BP ~ 1100BP</code>之间的扩增片段，然后再用酶把PCR扩出来的DNA片段再次片段化，所得到的的，应该是平均长度小于<code>180bp</code>的片段。</p></li>
<li><p>接着用末端核苷酸转移酶(Terminal Deoxy- nucleotidyl Transferase)将带有生物素的单核苷酸加到目标片段上</p></li>
<li><p>然后把这些带生物素标签的目标DNA片段与芯片进行杂交，在染色、扫描。</p>
<blockquote>
<p>目标DNA片段与捕获探针杂交过程中，如果完全匹配，则杂交率高，杂交到捕获探针上的目标片段就多，反之，如果有一个碱基不匹配，则杂交效率就会低很多，杂交到捕获探针上的目标片段就会少许多。</p>
</blockquote></li>
<li><p>接下来在进行染色，染色完成后，进行激光扫描。</p></li>
</ul>
<p><strong>结果说明：</strong>
扫描过程中，能发出荧光的探针，说明样本中有对应基因型的DNA；如果探针不能发出荧光信号或荧光信号很弱，说明样本中没有对应基因型的DNA；如果一个SNP的两种荧光探针都发光，且强度差不多，说明样本在该位置为杂合子。</p>
<blockquote>
<p>在卡式SNP芯片当中，<code>SNP 6.0</code>是一款很经典的芯片，上面有90多万个SNP位点的探针，并且同时还有94万个拷贝数变异探针。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="分析软件"></a><a href="#分析软件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析软件</h2>
<p>Affymetrix <strong>分析表达谱的软件</strong>主要是用<code>Transciptome Analysis Console</code>软件，简称<code>TAC软件</code>；<strong>分析基因分型的软件</strong> 主要是用<code>Genotyping Console</code>软件。</p>
<p>除了上面两种芯片，Affymetrix公司还提供了：microRNA芯片、基因调控芯片、拷贝数变异芯片、分子细胞遗传学芯片、药物遗传学芯片等。</p>
<p>from 陈巍学基因：Affymetrix芯片原理</p>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/Linux-best-practice/blog">Recent posts</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#芯片制造原理">芯片制造原理</a></li><li><a href="#表达谱芯片实验原理">表达谱芯片实验原理</a><ul class="toc-headings"><li><a href="#ivt芯片原理">IVT芯片原理</a></li><li><a href="#wt-芯片原理">WT 芯片原理</a></li></ul></li><li><a href="#snp分型芯片原理-基因分型芯片">SNP分型芯片原理（基因分型芯片）</a><ul class="toc-headings"><li><a href="#axiom方法及检测原理">Axiom方法及检测原理</a></li><li><a href="#卡式snp芯片原理">卡式SNP芯片原理</a></li></ul></li><li><a href="#分析软件">分析软件</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/Linux-best-practice/" class="nav-home"><img src="/Linux-best-practice/img/favicon.ico" alt="Kaige Dong&#x27;s Site" width="66" height="58"/></a><div><h5>Docs</h5><a href="/Linux-best-practice/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/Linux-best-practice/docs/en/doc2.html">Guides (or other categories)</a><a href="/Linux-best-practice/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/Linux-best-practice/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/Linux-best-practice/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/Linux-best-practice/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 Kaige Dong</section></footer></div></body></html>